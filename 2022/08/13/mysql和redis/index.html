<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"litianxing201930640094.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Mysql面试题1. 索引使用有哪些注意事项呢？ 隐式类型转换，会导致索引失效，例如age字段类型是int，我们where age &#x3D; “1”，这样就会触发隐式类型转换。 like通配符会导致索引失效。注意：”ABC%“会走range索引，”%ABC”索引才会失效。 联合索引，查询时的条件列不是联合索引中的第一个列，索引失效。 对索引字段进行函数运算或算术运算（如，+、-、*、&amp;#x2F">
<meta property="og:type" content="article">
<meta property="og:title" content="mysql和redis">
<meta property="og:url" content="https://litianxing201930640094.github.io/2022/08/13/mysql%E5%92%8Credis/index.html">
<meta property="og:site_name" content="最懂你的博客">
<meta property="og:description" content="Mysql面试题1. 索引使用有哪些注意事项呢？ 隐式类型转换，会导致索引失效，例如age字段类型是int，我们where age &#x3D; “1”，这样就会触发隐式类型转换。 like通配符会导致索引失效。注意：”ABC%“会走range索引，”%ABC”索引才会失效。 联合索引，查询时的条件列不是联合索引中的第一个列，索引失效。 对索引字段进行函数运算或算术运算（如，+、-、*、&amp;#x2F">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://litianxing201930640094.github.io/2022/08/13/mysql%E5%92%8Credis/v2-12f36a0aa2ea88020809173182e54e73_720w.jpg">
<meta property="og:image" content="https://litianxing201930640094.github.io/2022/08/13/mysql%E5%92%8Credis/image-20220318200549443.png">
<meta property="og:image" content="https://litianxing201930640094.github.io/2022/08/13/mysql%E5%92%8Credis/image-20220415101052047.png">
<meta property="og:image" content="https://litianxing201930640094.github.io/2022/08/13/mysql%E5%92%8Credis/1620.png">
<meta property="og:image" content="https://litianxing201930640094.github.io/2022/08/13/mysql%E5%92%8Credis/1620-16603835178821.png">
<meta property="og:image" content="https://litianxing201930640094.github.io/2022/08/13/mysql%E5%92%8Credis/1620-16603835178822.png">
<meta property="og:image" content="https://litianxing201930640094.github.io/2022/08/13/mysql%E5%92%8Credis/1620-16603835178823.png">
<meta property="og:image" content="https://litianxing201930640094.github.io/2022/08/13/mysql%E5%92%8Credis/1620-16603835178824.png">
<meta property="og:image" content="https://litianxing201930640094.github.io/2022/08/13/mysql%E5%92%8Credis/1620-16603835178825.png">
<meta property="og:image" content="https://litianxing201930640094.github.io/2022/08/13/mysql%E5%92%8Credis/1620-16603835178826.png">
<meta property="article:published_time" content="2022-08-13T09:38:16.000Z">
<meta property="article:modified_time" content="2022-08-13T09:47:24.476Z">
<meta property="article:author" content="Tianxing">
<meta property="article:tag" content="mysql">
<meta property="article:tag" content="redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://litianxing201930640094.github.io/2022/08/13/mysql%E5%92%8Credis/v2-12f36a0aa2ea88020809173182e54e73_720w.jpg">

<link rel="canonical" href="https://litianxing201930640094.github.io/2022/08/13/mysql%E5%92%8Credis/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>mysql和redis | 最懂你的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">	
    <script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":true,"debug":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false});</script>

  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">最懂你的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">a easy blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://litianxing201930640094.github.io/2022/08/13/mysql%E5%92%8Credis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/webb.jpg">
      <meta itemprop="name" content="Tianxing">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="最懂你的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          mysql和redis
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-13 17:38:16 / 修改时间：17:47:24" itemprop="dateCreated datePublished" datetime="2022-08-13T17:38:16+08:00">2022-08-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2022/08/13/mysql%E5%92%8Credis/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2022/08/13/mysql和redis/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Mysql面试题"><a href="#Mysql面试题" class="headerlink" title="Mysql面试题"></a>Mysql面试题</h1><h4 id="1-索引使用有哪些注意事项呢？"><a href="#1-索引使用有哪些注意事项呢？" class="headerlink" title="1. 索引使用有哪些注意事项呢？"></a>1. 索引使用有哪些注意事项呢？</h4><ol>
<li>隐式类型转换，会导致索引失效，例如age字段类型是int，我们where age &#x3D; “1”，这样就会触发隐式类型转换。</li>
<li>like通配符会导致索引失效。注意：”ABC%“会走range索引，”%ABC”索引才会失效。</li>
<li>联合索引，查询时的条件列不是联合索引中的第一个列，索引失效。</li>
<li>对索引字段进行函数运算或算术运算（如，+、-、*、&#x2F;），索引失效。</li>
<li>索引字段上使用（!&#x3D; 或者 &lt; &gt;，not in）时，会导致索引失效。</li>
<li>索引字段上使用is null， is not null，可能导致索引失效。</li>
<li>相join的两个表的字符编码不同，不能命中索引，会导致笛卡尔积的循环计算</li>
<li>mysql估计使用全表扫描要比使用索引快,则不使用索引</li>
</ol>
<h4 id="2-动态sql"><a href="#2-动态sql" class="headerlink" title="2. 动态sql"></a>2. 动态sql</h4><ol>
<li>动态拼接sql，加where 1 &#x3D; 1</li>
</ol>
<p>​		<a target="_blank" rel="noopener" href="https://www.cnblogs.com/muhy/p/11941931.html">SQL语句中where 1&#x3D;1的意义 - 永恒的回忆 - 博客园 (cnblogs.com)</a></p>
<ol start="2">
<li><strong>用mybatis的动态sql功能</strong></li>
</ol>
<p>​		<a target="_blank" rel="noopener" href="https://blog.csdn.net/sdgihshdv/article/details/78258886">(72条消息) 动态SQL_陈伟chenwei的博客-CSDN博客_动态sql</a></p>
<h4 id="3-数据库索引的原理，为什么要用-B-树，为什么不用其他树？"><a href="#3-数据库索引的原理，为什么要用-B-树，为什么不用其他树？" class="headerlink" title="3. 数据库索引的原理，为什么要用 B+树，为什么不用其他树？"></a>3. 数据库索引的原理，为什么要用 B+树，为什么不用其他树？</h4><ol>
<li><p><strong>二叉树</strong></p>
<p>1.1 当数据量大时，树的高度会比较高（树的高度决定着它的IO操作次数，IO操作耗时大），查询会比较慢。</p>
<p>2.2  每个磁盘块（节点&#x2F;页）保存的数据太小（IO本来是耗时操作，每次IO只能读取到一个关键字，显然不合适），没有很好的利用	操作磁盘IO的数据交换特性，也没有利用好磁盘IO的预读能力（空间局部性原理），从而带来频繁的IO操作。</p>
</li>
</ol>
<p>​	2. <strong>平衡二叉树</strong>可是每个节点只存储一个键值和数据</p>
<p>​	<strong>3. 那为什么不是B树而是B+树呢？</strong></p>
<p>​		<strong>B树和B+树的区别：</strong></p>
<ul>
<li>所有关键字存储在叶子节点出现,内部节点(非叶子节点并不存储真正的 data)</li>
<li>为所有叶子结点增加了一个链指针</li>
</ul>
<p>		</p>
<p>​		1）B+树叶节点两两相连可大大增加区间访问性，可使用在范围查询等，而B-树每个节点 key 和 data 在一起，则无法区间查找。<br>​		2）B+Tree磁盘读写能力更强,B+树单次磁盘 IO 的信息量大于B-树（叶子节点不保存真实数据，因此一个磁盘块能保存的关键字更			多，因此每次加载的关键字越多）<br>​		3）B+Tree扫表和扫库能力更强（B-Tree树需要扫描整颗树，B+Tree树只需要扫描叶子节点）</p>
<p>​		4)  B+树可以很好的利用局部性原理，若我们访问节点 key为 50，则 key 为 55、60、62 的节点将来也可能被访问，我们可以利用磁			盘预读原理提前将这些数据读入内存，减少了磁盘 IO 的次数。</p>
<h4 id="4-主键就是聚集索引"><a href="#4-主键就是聚集索引" class="headerlink" title="4.主键就是聚集索引"></a>4.<strong>主键就是聚集索引</strong></h4><p>​	主键默认是聚集索引，但是实际情况中聚合索引不一定要用到主键上。</p>
<p>​	例子：</p>
<p>​			在办公自动化系统中，无论是系统首页显示的需要用户签收的文件、会议还是用户进行文件查询等任何情况下进行数据查询都离不开字段的是“日期”还有用户本身的“用户名”。</p>
<p>  　　通常，办公自动化的首页会显示每个用户尚未签收的文件或会议。虽然我们的where语句可以仅仅限制当前用户尚未签收的情况，但如果您的系统已<strong>建立了很长时间，并且数据量很大</strong>，那么，每次每个用户打开首页的时候都进行一次全表扫描，这样做意义是不大的，绝大多数的用户1个月前的文件都已经浏览过了，这样做只能徒增数据库的开销而已。事实上，我们完全可以让用户打开系统首页时，数据库仅仅查询这个用户近3个月来未阅览的文件，通过“日期”这个字段来限制表扫描，提高查询速度。如果您的办公自动化系统已经建立的2年，那么您的首页显示速度理论上将是原来速度8倍，甚至更快。</p>
<h4 id="5-聚集索引"><a href="#5-聚集索引" class="headerlink" title="5. 聚集索引"></a>5. 聚集索引</h4><p>​	聚集索引是一种索引，该索引中键值的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%80%BB%E8%BE%91%E9%A1%BA%E5%BA%8F">逻辑顺序</a>决定了表中相应行的物理顺序。</p>
<p>​	逻辑顺序相邻的列在磁盘上连续分布；</p>
<p>​	<strong>建立聚集索引要求的</strong>：“既不能绝大多数都相同，又不能只有极少数相同”的规则</p>
<p>​	<strong>适用情况：</strong></p>
<pre><code>    1. 使用BETWEEN,&gt;,&gt;=,&lt;或&lt;=返回一个范围值的列
    1. 被连续访问的列
    1. 返回大型[结果集](https://baike.baidu.com/item/结果集)的查询
    1. 经常被使用连接或GROUP BY子句的查询访问的列
</code></pre>
<h4 id="6-主从复制的原理"><a href="#6-主从复制的原理" class="headerlink" title="6. 主从复制的原理"></a>6. <strong>主从复制的原理</strong></h4><p>首先放一张Mysql主从复制的原理图，总的来说Mysql的主从复制原理还是比较好理解的，原理非常的简单。</p>
<p><img src="/2022/08/13/mysql%E5%92%8Credis/v2-12f36a0aa2ea88020809173182e54e73_720w.jpg" alt="img"></p>
<p>Mysql的主从复制中主要有三个线程：<code>master（binlog dump thread）、slave（I/O thread 、SQL thread）</code>，Master一条线程和Slave中的两条线程。</p>
<p><code>master（binlog dump thread）</code>主要负责Master库中有数据更新的时候，会按照<code>binlog</code>格式，将更新的事件类型写入到主库的<code>binlog</code>文件中。</p>
<p>并且，Master会创建<code>log dump</code>线程通知Slave主库中存在数据更新，这就是为什么主库的binlog日志一定要开启的原因。</p>
<p><code>I/O thread</code>线程在Slave中创建，该线程用于请求Master，Master会返回binlog的名称以及当前数据更新的位置、binlog文件位置的副本。</p>
<p>然后，将<code>binlog</code>保存在 <strong>「relay log（中继日志）」</strong> 中，中继日志也是记录数据更新的信息。</p>
<p>SQL线程也是在Slave中创建的，当Slave检测到中继日志有更新，就会将更新的内容同步到Slave数据库中，这样就保证了主从的数据的同步。</p>
<p>以上就是主从复制的过程，当然，主从复制的过程有不同的策略方式进行数据的同步，主要包含以下几种：</p>
<ol>
<li><strong>「同步策略」</strong>：Master会等待所有的Slave都回应后才会提交，这个主从的同步的性能会严重的影响。</li>
<li><strong>「半同步策略」</strong>：Master至少会等待一个Slave回应后提交。</li>
<li><strong>「异步策略」</strong>：Master不用等待Slave回应就可以提交。</li>
<li><strong>「延迟策略」</strong>：Slave要落后于Master指定的时间。</li>
</ol>
<p>对于不同的业务需求，有不同的策略方案，但是一般都会采用最终一致性，不会要求强一致性，毕竟强一致性会严重影响性能。</p>
<h4 id="7-SQL查询A表中有B表中没有的数据"><a href="#7-SQL查询A表中有B表中没有的数据" class="headerlink" title="7. SQL查询A表中有B表中没有的数据"></a>7. SQL查询A表中有B表中没有的数据</h4><img src="/2022/08/13/mysql%E5%92%8Credis/image-20220318200549443.png" alt="image-20220318200549443" style="zoom:80%;">

<h4 id="8-游戏排行榜算法设计实现"><a href="#8-游戏排行榜算法设计实现" class="headerlink" title="8. 游戏排行榜算法设计实现"></a>8. 游戏排行榜算法设计实现</h4><p>​	<a target="_blank" rel="noopener" href="https://www.cnblogs.com/leestar54/p/13200549.html#top">排行榜的简单设计思路 - leestar54 - 博客园 (cnblogs.com)</a></p>
<ol>
<li><p>​	<strong>使用mysql：</strong></p>
<p>建立用户积分表，排行榜需要查询topN，在积分上建立索引，limit N；</p>
<h5 id="加缓存"><a href="#加缓存" class="headerlink" title="加缓存"></a>加缓存</h5><p>对于mysql来说，索引的增删查改也是需要维护的，所以如果对于需要频繁修改的排序字段，并且是非实时的排序需求（例如按小时、按天、按月等），我们可以考虑在写入前加缓存，避免频繁操作数据库，影响其性能。<br>例如：一分钟可能需要增减score字段值50次，那么我们可以由缓存先接手请求，等一分钟后，再统一写入数据库，那么这一分钟数据库操作的次数就少了50次，另外读取排行的时候也可以加缓存，效果显著。<br>当然缓存期越长，提升越多，但是也要考虑到缓存失效导致数据丢失等情况，来保证数据的一致性。</p>
</li>
<li><p><strong>积分排名数组实现</strong></p>
<p>如有1百万用户进行排名，就用一个大小为1，000，000的数组表示积分和排名的对应关系，其中rank[ s ]表示积分s所对应的排名。初始化时，rank数组可以由user_score表在O(n)的复杂度内计算而来。用户排名的查询和更新基于这个数组来进行。查询积分s所对应的排名直接返回rank[ s ]即可，复杂度为O(1)；当用户积分从s变为s+n，只需要把rank[ s ]到rank[s+n-1]这n个元素的值增加1即可，复杂度为O(n)。</p>
</li>
<li><p><strong>跳表</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/leestar54/p/13200549.html">排行榜的简单设计思路 - leestar54 - 博客园 (cnblogs.com)</a></p>
<p><strong>redis的有序集合(sorted set)</strong></p>
<p>有序集合是通过包含跳表和哈希表的双端口数据结构实现的，因此，每次添加元素时，Redis的复杂度都是O（log（N））。当我们要求排序的元素时，Redis根本不需要做任何工作，它已经全部排序了</p>
</li>
</ol>
<h4 id="9-三范式"><a href="#9-三范式" class="headerlink" title="9. 三范式"></a>9. 三范式</h4><pre><code>1. 字段不可再分
2. 非主键字段完全依赖主键字段，不可产生部分依赖；
3. 非主键字段之间不可产生依赖。
</code></pre>
<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="1-sql与nosql的区别"><a href="#1-sql与nosql的区别" class="headerlink" title="1. sql与nosql的区别"></a>1. sql与nosql的区别</h2><p><img src="/2022/08/13/mysql%E5%92%8Credis/image-20220415101052047.png" alt="image-20220415101052047"></p>
<h2 id="2-mysql与redis一致性问题认识MySQL和Redis的数据一致性问题-云-社区-腾讯云-tencent-com"><a href="#2-mysql与redis一致性问题认识MySQL和Redis的数据一致性问题-云-社区-腾讯云-tencent-com" class="headerlink" title="2. mysql与redis一致性问题认识MySQL和Redis的数据一致性问题 - 云+社区 - 腾讯云 (tencent.com)"></a>2. mysql与redis一致性问题<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1917325">认识MySQL和Redis的数据一致性问题 - 云+社区 - 腾讯云 (tencent.com)</a></h2><h3 id="2-1-针对只读缓存（先更新数据库再删除缓存）"><a href="#2-1-针对只读缓存（先更新数据库再删除缓存）" class="headerlink" title="2.1 针对只读缓存（先更新数据库再删除缓存）"></a><strong>2.1 针对只读缓存（先更新数据库再删除缓存）</strong></h3><p>只读缓存：新增数据时，直接写入数据库；更新（修改&#x2F;删除）数据时，先删除缓存。 后续，访问这些增删改的数据时，会发生缓存缺失，进而查询数据库，更新缓存。</p>
<ul>
<li><strong>新增数据时</strong> ，写入数据库；访问数据时，缓存缺失，查数据库，更新缓存（始终是处于”数据一致“的状态，不会发生数据不一致性问题)</li>
</ul>
<p><img src="/2022/08/13/mysql%E5%92%8Credis/1620.png" alt="img"></p>
<ul>
<li><strong>更新（修改&#x2F;删除）数据时</strong> ，会有个时序问题：更新数据库与删除缓存的顺序（这个过程会发生数据不一致性问题）</li>
</ul>
<p><img src="/2022/08/13/mysql%E5%92%8Credis/1620-16603835178821.png" alt="img"></p>
<p>在更新数据的过程中，可能会有如下问题：</p>
<ul>
<li>无并发请求下，其中一个操作失败的情况</li>
<li>并发请求下，其他线程可能会读到旧值</li>
</ul>
<p>因此，要想达到数据一致性，需要保证两点：</p>
<ul>
<li>无并发请求下，保证A和B步骤都能成功执行</li>
<li>并发请求下，在A和B步骤的间隔中，避免或消除其他线程的影响</li>
</ul>
<p>接下来，我们针对有&#x2F;无并发场景，进行分析并使用不同的策略。</p>
<h4 id="A-无并发情况"><a href="#A-无并发情况" class="headerlink" title="A. 无并发情况"></a><strong>A. 无并发情况</strong></h4><p>无并发请求下，在更新数据库和删除缓存值的过程中，因为操作被拆分成两步，那么就很有可能存在“步骤1成功，步骤2失败” 的情况发生（由于单线程中步骤1和步骤2是串行执行的，不太可能会发生 “步骤2成功，步骤1失败” 的情况）。</p>
<p><strong>(1) 先删除缓存，再更新数据库</strong> </p>
<p><img src="/2022/08/13/mysql%E5%92%8Credis/1620-16603835178822.png" alt="img"></p>
<p><strong>(2) 先更新数据库，再删除缓存</strong>  </p>
<p><img src="/2022/08/13/mysql%E5%92%8Credis/1620-16603835178823.png" alt="img"></p>
<table>
<thead>
<tr>
<th align="left">执行时序</th>
<th align="left">潜在问题</th>
<th align="left">结果</th>
<th align="left">是否存在一致性问题</th>
</tr>
</thead>
<tbody><tr>
<td align="left">先删除缓存，后更新数据库</td>
<td align="left">删除缓存成功，更新数据库失败</td>
<td align="left">请求无法命中缓存，读取数据库旧值</td>
<td align="left">是</td>
</tr>
<tr>
<td align="left">先更新数据库，后删除缓存</td>
<td align="left">更新数据库成功，删除缓存失败</td>
<td align="left">请求命中缓存，读取缓存旧值</td>
<td align="left">是</td>
</tr>
</tbody></table>
<p><strong>解决策略：</strong> </p>
<h5 id="a-消息队列-异步重试"><a href="#a-消息队列-异步重试" class="headerlink" title="a.消息队列+异步重试"></a><strong>a.消息队列+异步重试</strong></h5><p>无论使用哪一种执行时序，可以在执行步骤1时，将步骤2的请求写入消息队列，当步骤2失败时，就可以使用重试策略，对失败操作进行 “补偿”。 </p>
<p><img src="/2022/08/13/mysql%E5%92%8Credis/1620-16603835178824.png" alt="img"></p>
<p><strong>具体步骤如下：</strong></p>
<ol>
<li>把要删除缓存值或者是要更新数据库值操作生成消息，暂存到消息队列中（例如使用 Kafka 消息队列）；</li>
<li>当删除缓存值或者是更新数据库值操作成功时，把这些消息从消息队列中去除（丢弃），以免重复操作；</li>
<li>当删除缓存值或者是更新数据库值操作失败时，执行失败策略，重试服务从消息队列中重新读取（消费）这些消息，然后再次进行删除或更新；</li>
<li>删除或者更新失败时，需要再次进行重试，重试超过的一定次数，向业务层发送报错信息。</li>
</ol>
<h5 id="b-订阅Binlog变更日志"><a href="#b-订阅Binlog变更日志" class="headerlink" title="b.订阅Binlog变更日志"></a><strong>b.订阅Binlog变更日志</strong></h5><ul>
<li>创建更新缓存服务，接收数据变更的MQ消息，然后消费消息，更新&#x2F;删除Redis中的缓存数据；</li>
<li>使用 Binlog 实时更新&#x2F;删除Redis 缓存。利用Canal，即将负责更新缓存的服务伪装成一个 MySQL 的从节点，从 MySQL 接收 Binlog，解析 Binlog 之后，得到实时的数据变更信息，然后根据变更信息去更新&#x2F;删除 Redis 缓存；</li>
<li>MQ+Canal策略，将Canal Server接收到的Binlog数据直接投递到MQ进行解耦，使用MQ异步消费Binlog日志，以此进行数据同步；</li>
</ul>
<p>不管用 MQ&#x2F;Canal或者MQ+Canal的策略来异步更新缓存，对整个更新服务的数据可靠性和实时性要求都比较高，如果产生数据丢失或者更新延时情况，会造成MySQL和Redis 中的数据不一致。因此，使用这种策略时，需要考虑出现不同步问题时的降级或补偿方案。</p>
<h4 id="B-高并发情况"><a href="#B-高并发情况" class="headerlink" title="B. 高并发情况"></a><strong>B. 高并发情况</strong></h4><p>使用以上策略后，可以保证在单线程&#x2F;无并发场景下的数据一致性。但是，在高并发场景下，由于数据库层面的读写并发，会引发的数据库与缓存数据不一致的问题（本质是后发生的读请求先返回了）</p>
<h5 id="1-先删除缓存，再更新数据库"><a href="#1-先删除缓存，再更新数据库" class="headerlink" title="(1) 先删除缓存，再更新数据库"></a><strong>(1) 先删除缓存，再更新数据库</strong></h5><p>假设线程 A 删除缓存值后，由于网络延迟等原因导致未及更新数据库，而此时，线程 B 开始读取数据时会发现缓存缺失，进而去查询数据库。而当线程 B 从数据库读取完数据、更新了缓存后，线程 A 才开始更新数据库，此时，会导致缓存中的数据是旧值，而数据库中的是最新值，产生“数据不一致”。其本质就是，本应后发生的“B线程-读请求” 先于 “A线程-写请求” 执行并返回了。</p>
<table>
<thead>
<tr>
<th align="left">时间</th>
<th align="left">线程A</th>
<th align="left">线程B</th>
<th align="left">问题</th>
</tr>
</thead>
<tbody><tr>
<td align="left">T1</td>
<td align="left">删除数据X的缓存值</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">T2</td>
<td align="left"></td>
<td align="left">1.读取缓存数据X，缓存缺失，从数据库读取数据X</td>
<td align="left">线程B读取到旧值</td>
</tr>
<tr>
<td align="left">T3</td>
<td align="left"></td>
<td align="left">2.将数据X的值写入缓存</td>
<td align="left">导致其他线程读到旧值</td>
</tr>
<tr>
<td align="left">T4</td>
<td align="left">更新数据库中的数据X的值</td>
<td align="left"></td>
<td align="left">缓存是旧值，数据库是旧值，导致数据不一致</td>
</tr>
</tbody></table>
<p>或者</p>
<table>
<thead>
<tr>
<th align="left">时间</th>
<th align="left">线程A</th>
<th align="left">线程B</th>
<th align="left">问题</th>
</tr>
</thead>
<tbody><tr>
<td align="left">T1</td>
<td align="left">删除数据X的缓存值</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">T2</td>
<td align="left"></td>
<td align="left">1.读取缓存数据X，缓存缺失，从数据库读取数据X</td>
<td align="left">线程B读取到旧值</td>
</tr>
<tr>
<td align="left">T3</td>
<td align="left">更新数据库中的数据X的值</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">T4</td>
<td align="left"></td>
<td align="left">2.将数据X的值写入缓存</td>
<td align="left">缓存是旧值，数据库是旧值，导致数据不一致</td>
</tr>
</tbody></table>
<p><strong>解决策略：</strong> </p>
<h6 id="a-设置缓存过期时间-延时双删"><a href="#a-设置缓存过期时间-延时双删" class="headerlink" title="a.设置缓存过期时间 + 延时双删"></a><strong>a.设置缓存过期时间 + 延时双删</strong></h6><p>通过设置缓存过期时间，若发生上述淘汰缓存失败的情况，则在缓存过期后，读请求仍然可以从DB中读取最新数据并更新缓存，可减小数据不一致的影响范围。虽然在一定时间范围内数据有差异，但可以保证数据的最终一致性。</p>
<p>此外，还可以通过延时双删进行保障：在线程 A 更新完数据库值以后，让它先 sleep 一小段时间，确保线程 B 能够先从数据库读取数据，再把缺失的数据写入缓存，然后，线程 A 再进行删除。后续，其它线程读取数据时，发现缓存缺失，会从数据库中读取最新值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis.<span class="title function_">delKey</span>(X)</span><br><span class="line">db.<span class="title function_">update</span>(X)</span><br><span class="line"><span class="title class_">Thread</span>.<span class="title function_">sleep</span>(N)</span><br><span class="line">redis.<span class="title function_">delKey</span>(X)</span><br></pre></td></tr></table></figure>

<p>复制</p>
<p>sleep时间：在业务程序运行的时候，统计下线程读数据和写缓存的操作时间，以此为基础来进行估算</p>
<table>
<thead>
<tr>
<th align="left">时间</th>
<th align="left">线程A</th>
<th align="left">线程C</th>
<th align="left">线程D</th>
<th align="left">问题</th>
</tr>
</thead>
<tbody><tr>
<td align="left">T5</td>
<td align="left">sleep(N)</td>
<td align="left">读取到缓存旧值</td>
<td align="left"></td>
<td align="left">其他线程可能在此期间读到旧值</td>
</tr>
<tr>
<td align="left">T6</td>
<td align="left">删除数据X的缓存值</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">T7</td>
<td align="left"></td>
<td align="left"></td>
<td align="left">缓存缺失，从数据库读取数据X的最新值</td>
<td align="left"></td>
</tr>
</tbody></table>
<p><strong>注意</strong>：如果难以接受sleep这种写法，可以使用延时队列进行替代。</p>
<p>先删除缓存值再更新数据库，有可能导致请求因缓存缺失而访问数据库，给数据库带来压力，也就是缓存穿透的问题。针对缓存穿透问题，可以用缓存空结果、布隆过滤器进行解决。</p>
<h5 id="2-先更新数据库，再删除缓存"><a href="#2-先更新数据库，再删除缓存" class="headerlink" title="(2) 先更新数据库，再删除缓存"></a><strong>(2) 先更新数据库，再删除缓存</strong></h5><p>如果线程 A 更新了数据库中的值，但还没来得及删除缓存值，线程 B 就开始读取数据了，那么此时，线程 B 查询缓存时，发现缓存命中，就会直接从缓存中读取旧值。其本质也是，本应后发生的“B线程-读请求” 先于 “A线程-删除缓存” 执行并返回了。</p>
<table>
<thead>
<tr>
<th align="left">时间</th>
<th align="left">线程A</th>
<th align="left">线程B</th>
<th align="left">潜在问题</th>
</tr>
</thead>
<tbody><tr>
<td align="left">T1</td>
<td align="left">更新数据库中的数据X</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">T2</td>
<td align="left"></td>
<td align="left">读取数据X，命中缓存，从缓存中读取X，读取旧值</td>
<td align="left">线程A尚未删除缓存值，导致线程B读到旧值</td>
</tr>
<tr>
<td align="left">T3</td>
<td align="left">删除缓存的数据X</td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<p>或者，在”先更新数据库，再删除缓存”方案下，“读写分离 + 主从库延迟”也会导致不一致：</p>
<table>
<thead>
<tr>
<th align="left">时间</th>
<th align="left">线程A</th>
<th align="left">线程B</th>
<th align="left">MySQL集群</th>
<th align="left">潜在问题</th>
</tr>
</thead>
<tbody><tr>
<td align="left">T1</td>
<td align="left">更新主库 X &#x3D; 2（原值 X &#x3D; 1）</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">T2</td>
<td align="left">删除缓存</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">T3</td>
<td align="left"></td>
<td align="left">查询缓存，没有命中，查询从库，得到旧值（从库 X &#x3D; 1）</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">T4</td>
<td align="left"></td>
<td align="left">将旧值写入缓存（X &#x3D; 1）</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">T5</td>
<td align="left"></td>
<td align="left"></td>
<td align="left">从库同步完成（主从库 X &#x3D; 2）</td>
<td align="left">最终 X 的值在缓存中是 1（旧值），在主从库中是 2（新值），也发生不一致</td>
</tr>
</tbody></table>
<p><strong>解决方案：</strong> </p>
<p><strong>a.延迟消息</strong> </p>
<p>凭借经验发送「延迟消息」到队列中，延迟删除缓存，同时也要控制主从库延迟，尽可能降低不一致发生的概率</p>
<p><strong>b.订阅binlog，异步删除</strong> </p>
<p>通过数据库的binlog来异步淘汰key，利用工具(canal)将binlog日志采集发送到MQ中，然后通过ACK机制确认处理删除缓存。</p>
<p><strong>d.加锁</strong></p>
<p>更新数据时，加写锁；查询数据时，加读锁 保证两步操作的“原子性”，使得操作可以串行执行。“<strong>原子性”的本质是什么？不可分割只是外在表现，其本质是多个资源间有一致性的要求，操作的中间状态对外不可见。</strong> </p>
<p><img src="/2022/08/13/mysql%E5%92%8Credis/1620-16603835178825.png" alt="img"></p>
<h5 id="优先使用“先更新数据库再删除缓存”，原因："><a href="#优先使用“先更新数据库再删除缓存”，原因：" class="headerlink" title="优先使用“先更新数据库再删除缓存”，原因："></a>优先使用“先更新数据库再删除缓存”，原因：</h5><ol>
<li>先删除缓存值再更新数据库，有可能导致请求因缓存缺失而访问数据库，给数据库带来压力；</li>
<li>业务应用中读取数据库和写缓存的时间有时不好估算，进而导致延迟双删中的sleep时间不好设置。</li>
</ol>
<h3 id="2-2-针对读写缓存（先更新缓存再更新数据库）"><a href="#2-2-针对读写缓存（先更新缓存再更新数据库）" class="headerlink" title="2.2 针对读写缓存（先更新缓存再更新数据库）"></a><strong>2.2 针对读写缓存（先更新缓存再更新数据库）</strong></h3><p>读写缓存：增删改在缓存中进行，并采取相应的回写策略，同步数据到数据库中</p>
<ul>
<li>同步直写：使用事务，保证缓存和数据更新的原子性，并进行失败重试（如果Redis 本身出现故障，会降低服务的性能和可用性）</li>
<li>异步回写：写缓存时不同步写数据库，等到数据从缓存中淘汰时，再写回数据库（没写回数据库前，缓存发生故障，会造成数据丢失） 该策略在秒杀场中有见到过，业务层直接对缓存中的秒杀商品库存信息进行操作，一段时间后再回写数据库。</li>
</ul>
<p>一致性：同步直写 &gt; 异步回写 因此，对于读写缓存，要保持数据强一致性的主要思路是：利用同步直写 同步直写也存在两个操作的时序问题：更新数据库和更新缓存</p>
<h4 id="A-无并发情况-与只读缓存处理措施一样"><a href="#A-无并发情况-与只读缓存处理措施一样" class="headerlink" title="A. 无并发情况(与只读缓存处理措施一样)"></a><strong>A. 无并发情况</strong>(与只读缓存处理措施一样)</h4><table>
<thead>
<tr>
<th align="left">执行顺序</th>
<th align="left">潜在问题</th>
<th align="left">结果</th>
<th align="left">是否存在一致性问题</th>
<th align="left">解决策略</th>
</tr>
</thead>
<tbody><tr>
<td align="left">先更新缓存，后更新数据库</td>
<td align="left">更新缓存成功，更新数据库失败</td>
<td align="left">数据库中为旧值</td>
<td align="left">是</td>
<td align="left">消息队列+重试机制</td>
</tr>
<tr>
<td align="left">先更新数据库，后更新缓存</td>
<td align="left">更新数据库成功，更新缓存失败</td>
<td align="left">请求命中缓存，读取缓存旧值</td>
<td align="left">是</td>
<td align="left">消息队列+重试机制；订阅Binlog日志</td>
</tr>
</tbody></table>
<h4 id="B-高并发情况-1"><a href="#B-高并发情况-1" class="headerlink" title="B. 高并发情况"></a><strong>B. 高并发情况</strong></h4><p>有四种场景会造成数据不一致：</p>
<table>
<thead>
<tr>
<th align="left">时序</th>
<th align="left">并发类型</th>
<th align="left">潜在问题</th>
<th align="left">影响程度</th>
</tr>
</thead>
<tbody><tr>
<td align="left">先更新数据库，再更新缓存</td>
<td align="left">写+读并发</td>
<td align="left">1.线程A先更新数据库 2.线程B读取数据，命中缓存，读取到旧值 3.线程A更新缓存成功，后续的读请求会命中缓存得到最新值</td>
<td align="left">这种场景下，线程A未更新完缓存之前，在这期间的读请求会短暂读到旧值，对业务短暂影响</td>
</tr>
<tr>
<td align="left"><strong>先更新缓存，再更新数据库</strong></td>
<td align="left">写+读并发</td>
<td align="left">1.线程A先更新缓存成功 2.线程B读取数据，此时线程B命中缓存，读取到最新值后返回 3.线程A更新数据库成功</td>
<td align="left">这种场景下，虽然线程A还未更新完数据库，数据库会与缓存存在短暂不一致，但在这之前进来的读请求都能直接命中缓存，获取到最新值对业务影响较小</td>
</tr>
<tr>
<td align="left">先更新数据库，再更新缓存</td>
<td align="left">写+写并发</td>
<td align="left">1.线程A和线程B同时更新同一条数据 2.更新数据库的顺序是先A后B 3.更新缓存时顺序是先B后A</td>
<td align="left">会导致数据库和缓存的不一致，对业务影响较大</td>
</tr>
<tr>
<td align="left">先更新缓存，再更新数据库</td>
<td align="left">写+写并发</td>
<td align="left">1.线程A和线程B同时更新同一条数据 2.更新缓存的顺序是先A后B 3.更新数据库的顺序是先B后A</td>
<td align="left">会导致数据库和缓存的不一致，对业务影响较大</td>
</tr>
</tbody></table>
<p>针对场景1和2的解决方案是：保存请求对缓存的读取记录，延时消息比较，发现不一致后，做业务补偿 针对场景3和4的解决方案是：对于写请求，需要配合分布式锁使用。写请求进来时，针对同一个资源的修改操作，先加分布式锁，保证同一时间只有一个线程去更新数据库和缓存；没有拿到锁的线程把操作放入到队列中，延时处理。用这种方式保证多个线程操作同一资源的顺序性，以此保证一致性。 </p>
<p><img src="/2022/08/13/mysql%E5%92%8Credis/1620-16603835178826.png" alt="img"></p>
<p> 其中，分布式锁的实现可以使用以下策略：</p>
<table>
<thead>
<tr>
<th align="left">分布式锁策略</th>
<th align="left">实现原理</th>
</tr>
</thead>
<tbody><tr>
<td align="left">乐观锁</td>
<td align="left">使用版本号、updatetime；缓存中，只允许高版本覆盖低版本</td>
</tr>
<tr>
<td align="left">Watch实现Redis乐观锁+redis事务</td>
<td align="left">watch监控redisKey的状态值，创建redis事务，key+1，执行事务，key被修改过则回滚</td>
</tr>
<tr>
<td align="left">setnx</td>
<td align="left">获取锁：set&#x2F;setnx；释放锁：del命令&#x2F;lua脚本</td>
</tr>
<tr>
<td align="left">Redisson分布式锁</td>
<td align="left">利用Redis的Hash结构作为储存单元，将业务指定的名称作为key，将随机UUID和线程ID作为field，最后将加锁的次数作为value来储存；线程安全</td>
</tr>
</tbody></table>
<h3 id="2-3-强一致性策略"><a href="#2-3-强一致性策略" class="headerlink" title="2.3 强一致性策略"></a><strong>2.3 强一致性策略</strong></h3><p>上述策略只能保证数据的最终一致性。 要想做到强一致，最常见的方案是 2PC、3PC、Paxos、Raft 这类一致性协议，但它们的性能往往比较差，而且这些方案也比较复杂，还要考虑各种容错问题。 如果业务层要求必须读取数据的强一致性，可以采取以下策略：</p>
<p><strong>（1）暂存并发读请求</strong> </p>
<p>在更新数据库时，先在 Redis 缓存客户端暂存并发读请求，等数据库更新完、缓存值删除后，再读取数据，从而保证数据一致性。</p>
<p><strong>（2）串行化</strong> </p>
<p>读写请求入队列，工作线程从队列中取任务来依次执行</p>
<ol>
<li>修改服务Service连接池，id取模选取服务连接，能够保证同一个数据的读写都落在同一个后端服务上</li>
<li>修改数据库DB连接池，id取模选取DB连接，能够保证同一个数据的读写在数据库层面是串行的</li>
</ol>
<p><strong>（3）使用Redis分布式读写锁</strong> </p>
<p>将淘汰缓存与更新库表放入同一把写锁中，与其它读请求互斥，防止其间产生旧数据。读写互斥、写写互斥、读读共享，可满足读多写少的场景数据一致，也保证了并发性。并根据逻辑平均运行时间、响应超时时间来确定过期时间。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">void</span> <span class="title function_">write</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title class_">Lock</span> writeLock = redis.<span class="title function_">getWriteLock</span>(lockKey);</span><br><span class="line">    writeLock.<span class="title function_">lock</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        redis.<span class="title function_">delete</span>(key);</span><br><span class="line">        db.<span class="title function_">update</span>(record);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        writeLock.<span class="title function_">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">void</span> <span class="title function_">read</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (caching) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// no cache</span></span><br><span class="line">    <span class="title class_">Lock</span> readLock = redis.<span class="title function_">getReadLock</span>(lockKey);</span><br><span class="line">    readLock.<span class="title function_">lock</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        record = db.<span class="title function_">get</span>();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        readLock.<span class="title function_">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    redis.<span class="title function_">set</span>(key, record);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复制</p>
<h3 id="2-4-小结"><a href="#2-4-小结" class="headerlink" title="2.4 小结"></a><strong>2.4 小结</strong></h3><table>
<thead>
<tr>
<th align="left">缓存类型</th>
<th align="left">一致性主要策略</th>
<th align="left">优点</th>
<th align="left">缺点</th>
<th align="left">适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="left">读写缓存</td>
<td align="left">更新数据库+更新缓存</td>
<td align="left">缓存中一直会有数据，如果更新操作后会立即再次访问，可以直接命中缓存，能够降低读请求对于数据库的压力</td>
<td align="left">如果更新后的数据，之后很少再被访问到，会导致缓存中保留的不是最热的数据，缓存利用率不高，浪费缓存资源</td>
<td align="left">读写相当</td>
</tr>
<tr>
<td align="left">只读缓存</td>
<td align="left">更新数据库+删除缓存</td>
<td align="left">只读缓存中保留的都是热数据，缓存利用率高</td>
<td align="left">删除缓存导致缓存缺失和再加载的过程；缓存缺失时，导致大量请求落到数据库，压垮数据库</td>
<td align="left">读多写少</td>
</tr>
</tbody></table>
<p>针对读写缓存时：同步直写，更新数据库+更新缓存</p>
<table>
<thead>
<tr>
<th align="left">操作顺序</th>
<th align="left">是否有并发请求</th>
<th align="left">潜在问题</th>
<th align="left">结果</th>
<th align="left">应对方案</th>
</tr>
</thead>
<tbody><tr>
<td align="left">先更新数据库，再更新缓存</td>
<td align="left">无</td>
<td align="left">数据库更新成功，但更新缓存失败</td>
<td align="left">请求从缓存读到旧数据</td>
<td align="left">重试缓存更新</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">写+读</td>
<td align="left">线程A未更新完缓存之前，线程B的读请求会短暂读到旧值</td>
<td align="left">请求从短暂缓存读到旧数据</td>
<td align="left">保存读取记录，做补偿</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">写+写</td>
<td align="left">更新数据库的顺序是先A后B，但更新缓存时顺序是先B后A</td>
<td align="left">数据库和缓存数据不一致</td>
<td align="left">分布式锁</td>
</tr>
<tr>
<td align="left">先更新缓存，再更新数据库</td>
<td align="left">无</td>
<td align="left">缓存更新成功，但更新数据库失败</td>
<td align="left">数据库存在旧值</td>
<td align="left">重试数据库更新</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">写+读</td>
<td align="left">线程A还未更新完数据库，但在这之前进来的读请求都能直接命中缓存，获取到最新值</td>
<td align="left">数据库与缓存存在短暂不一致，但不影响业务</td>
<td align="left">MQ确认数据库更新成功</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">写+写</td>
<td align="left">更新缓存的顺序是先A后B，但更新数据库时顺序是先B后A</td>
<td align="left">数据库和缓存数据不一致</td>
<td align="left">分布式锁</td>
</tr>
</tbody></table>
<p>针对只读缓存时：更新数据库+删除缓存</p>
<table>
<thead>
<tr>
<th align="left">操作顺序</th>
<th align="left">是否有并发请求</th>
<th align="left">潜在问题</th>
<th align="left">现象</th>
<th align="left">应对方案</th>
</tr>
</thead>
<tbody><tr>
<td align="left">先删除缓存值，再更新数据库</td>
<td align="left">无</td>
<td align="left">缓存删除成功，但数据库更新失败</td>
<td align="left">请求从数据库读到旧数据</td>
<td align="left">重试数据库更新</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">有</td>
<td align="left">缓存删除后，尚未更新数据库，有并发读请求</td>
<td align="left">并发请求从数据库读到旧值，并且更新到缓存，导致后续请求都读取旧值</td>
<td align="left">延迟双删；加锁</td>
</tr>
<tr>
<td align="left">先更新数据库，再删除缓存</td>
<td align="left">无</td>
<td align="left">数据库更新成功，但缓存删除失败</td>
<td align="left">请求从缓存读到旧数据</td>
<td align="left">重试缓存删除</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">有</td>
<td align="left">数据库更新成功后，尚未删除缓存，有并发读请求</td>
<td align="left">并发请求从缓存中读到旧值</td>
<td align="left">延迟消息；订阅变更日志；加锁</td>
</tr>
</tbody></table>
<p><strong>较为通用的一致性策略拟定：</strong> </p>
<p>在并发场景下，使用 “更新数据库 + 更新缓存” 需要用分布式锁保证缓存和数据一致性，且可能存在”缓存资源浪费“和”机器性能浪费“的情况；一般推荐使用 “更新数据库 + 删除缓存” 的方案。如果根据需要，热点数据较多，可以使用 “更新数据库 + 更新缓存” 策略。</p>
<p>在 “更新数据库 + 删除缓存” 的方案中，推荐使用推荐用 “先更新数据库，再删除缓存” 策略，因为先删除缓存可能会导致大量请求落到数据库，而且延迟双删的时间很难评估。 在 “先更新数据库，再删除缓存” 策略中，可以使用“消息队列+重试机制” 的方案保证缓存的删除。 并通过 “订阅binlog” 进行缓存比对，加上一层保障。</p>
<p>此外，需要通过初始化缓存预热、多数据源触发、延迟消息比对等策略进行辅助和补偿。 【多种数据更新触发源：定时任务扫描，业务系统 MQ、binlog 变更 MQ，相互之间作为互补来保证数据不会漏更新】</p>
<h3 id="3-数据一致性中需要注意的其他问题有哪些？"><a href="#3-数据一致性中需要注意的其他问题有哪些？" class="headerlink" title="3. 数据一致性中需要注意的其他问题有哪些？"></a><strong>3. 数据一致性中需要注意的其他问题有哪些？</strong></h3><h4 id="3-1-k-v大小的合理设置"><a href="#3-1-k-v大小的合理设置" class="headerlink" title="3.1 k-v大小的合理设置"></a><strong>3.1 k-v大小的合理设置</strong></h4><blockquote>
<p><strong>Redis key大小设计：</strong> 由于网络的一次传输MTU最大为1500字节，所以为了保证高效的性能，建议单个k-v大小不超过1KB，一次网络传输就能完成，避免多次网络交互；k-v是越小性能越好 <strong>Redis 热key：</strong>（1） 当业务遇到单个读热key，通过增加副本来提高读能力或是用hashtag把key存多份在多个分片中；（2）当业务遇到单个写热key，需业务拆分这个key的功能，属于设计不合理- 当业务遇到热分片，即多个热key在同一个分片上导致单分片cpu高，可通过hashtag方式打散</p>
</blockquote>
<h4 id="3-2-避免其他问题导致缓存服务器崩溃，进而简直导致数据一致性策略失效"><a href="#3-2-避免其他问题导致缓存服务器崩溃，进而简直导致数据一致性策略失效" class="headerlink" title="3.2 避免其他问题导致缓存服务器崩溃，进而简直导致数据一致性策略失效"></a><strong>3.2 避免其他问题导致缓存</strong><a target="_blank" rel="noopener" href="https://cloud.tencent.com/product/cvm?from=10680"><strong>服务器</strong></a><strong>崩溃，进而简直导致数据一致性策略失效</strong></h4><p>如缓存穿透、缓存击穿、缓存雪崩、机器故障等问题</p>
<table>
<thead>
<tr>
<th align="left">问题</th>
<th align="left">描述</th>
<th align="left">解决方案</th>
</tr>
</thead>
<tbody><tr>
<td align="left">缓存穿透</td>
<td align="left">查询一个不存在的数据，不能命中缓存，导致每次请求都要到DB去查询，可能导致数据库崩溃</td>
<td align="left">1.查询返回的数据为空，仍把这个空结果进行缓存，但过期时间会比较短； 2.布隆过滤器：将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对DB的查询</td>
</tr>
<tr>
<td align="left">缓存击穿</td>
<td align="left">对于设置了过期时间的key，缓存在某个时间点过期的时候，恰好有大量对这个key的并发请求，可能导致大量并发的请求瞬间把数据库压垮</td>
<td align="left">1.使用互斥锁：当缓存失效时，先使用如Redis的setnx去设置一个互斥锁，当操作成功返回时再进行数据库操作并回设缓存，否则重试get缓存的方法； 2.永远不过期：物理不过期，但逻辑过期（后台异步线程去刷新）</td>
</tr>
<tr>
<td align="left">缓存雪崩</td>
<td align="left">设置缓存时采用了相同的过期时间，缓存在某一时刻同时失效，导致大量请求访问数据库。 与缓存击穿的区别：雪崩是多key，击穿是单key缓存</td>
<td align="left">1.分散缓存失效时间：在原有的失效时间基础上增加一个随机值； 2. 使用互斥锁，当缓存数据失效时，保证只有一个请求能够访问到数据库，并更新缓存，其他线程等待并重试</td>
</tr>
</tbody></table>
<h4 id="3-3-方案选定的思路"><a href="#3-3-方案选定的思路" class="headerlink" title="3.3 方案选定的思路"></a><strong>3.3 方案选定的思路</strong></h4><ol>
<li>确定缓存类型（读写&#x2F;只读）</li>
<li>确定一致性级别</li>
<li>确定同步&#x2F;异步方式</li>
<li>选定缓存流程</li>
<li>补充细节</li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/mysql/" rel="tag"># mysql</a>
              <a href="/tags/redis/" rel="tag"># redis</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/08/13/java%E5%9F%BA%E7%A1%80/" rel="prev" title="java基础">
      <i class="fa fa-chevron-left"></i> java基础
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Mysql%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-number">1.</span> <span class="nav-text">Mysql面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E7%B4%A2%E5%BC%95%E4%BD%BF%E7%94%A8%E6%9C%89%E5%93%AA%E4%BA%9B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%91%A2%EF%BC%9F"><span class="nav-number">1.0.0.1.</span> <span class="nav-text">1. 索引使用有哪些注意事项呢？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%8A%A8%E6%80%81sql"><span class="nav-number">1.0.0.2.</span> <span class="nav-text">2. 动态sql</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8-B-%E6%A0%91%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8%E5%85%B6%E4%BB%96%E6%A0%91%EF%BC%9F"><span class="nav-number">1.0.0.3.</span> <span class="nav-text">3. 数据库索引的原理，为什么要用 B+树，为什么不用其他树？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E4%B8%BB%E9%94%AE%E5%B0%B1%E6%98%AF%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95"><span class="nav-number">1.0.0.4.</span> <span class="nav-text">4.主键就是聚集索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95"><span class="nav-number">1.0.0.5.</span> <span class="nav-text">5. 聚集索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">1.0.0.6.</span> <span class="nav-text">6. 主从复制的原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-SQL%E6%9F%A5%E8%AF%A2A%E8%A1%A8%E4%B8%AD%E6%9C%89B%E8%A1%A8%E4%B8%AD%E6%B2%A1%E6%9C%89%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="nav-number">1.0.0.7.</span> <span class="nav-text">7. SQL查询A表中有B表中没有的数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-%E6%B8%B8%E6%88%8F%E6%8E%92%E8%A1%8C%E6%A6%9C%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.0.0.8.</span> <span class="nav-text">8. 游戏排行榜算法设计实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8A%A0%E7%BC%93%E5%AD%98"><span class="nav-number">1.0.0.8.1.</span> <span class="nav-text">加缓存</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-%E4%B8%89%E8%8C%83%E5%BC%8F"><span class="nav-number">1.0.0.9.</span> <span class="nav-text">9. 三范式</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis"><span class="nav-number">2.</span> <span class="nav-text">Redis</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-sql%E4%B8%8Enosql%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.1.</span> <span class="nav-text">1. sql与nosql的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-mysql%E4%B8%8Eredis%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98%E8%AE%A4%E8%AF%86MySQL%E5%92%8CRedis%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98-%E4%BA%91-%E7%A4%BE%E5%8C%BA-%E8%85%BE%E8%AE%AF%E4%BA%91-tencent-com"><span class="nav-number">2.2.</span> <span class="nav-text">2. mysql与redis一致性问题认识MySQL和Redis的数据一致性问题 - 云+社区 - 腾讯云 (tencent.com)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E9%92%88%E5%AF%B9%E5%8F%AA%E8%AF%BB%E7%BC%93%E5%AD%98%EF%BC%88%E5%85%88%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E5%86%8D%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98%EF%BC%89"><span class="nav-number">2.2.1.</span> <span class="nav-text">2.1 针对只读缓存（先更新数据库再删除缓存）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#A-%E6%97%A0%E5%B9%B6%E5%8F%91%E6%83%85%E5%86%B5"><span class="nav-number">2.2.1.1.</span> <span class="nav-text">A. 无并发情况</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#a-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-%E5%BC%82%E6%AD%A5%E9%87%8D%E8%AF%95"><span class="nav-number">2.2.1.1.1.</span> <span class="nav-text">a.消息队列+异步重试</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#b-%E8%AE%A2%E9%98%85Binlog%E5%8F%98%E6%9B%B4%E6%97%A5%E5%BF%97"><span class="nav-number">2.2.1.1.2.</span> <span class="nav-text">b.订阅Binlog变更日志</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B-%E9%AB%98%E5%B9%B6%E5%8F%91%E6%83%85%E5%86%B5"><span class="nav-number">2.2.1.2.</span> <span class="nav-text">B. 高并发情况</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%85%88%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98%EF%BC%8C%E5%86%8D%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">2.2.1.2.1.</span> <span class="nav-text">(1) 先删除缓存，再更新数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#a-%E8%AE%BE%E7%BD%AE%E7%BC%93%E5%AD%98%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4-%E5%BB%B6%E6%97%B6%E5%8F%8C%E5%88%A0"><span class="nav-number">2.2.1.2.1.1.</span> <span class="nav-text">a.设置缓存过期时间 + 延时双删</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%85%88%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%8C%E5%86%8D%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98"><span class="nav-number">2.2.1.2.2.</span> <span class="nav-text">(2) 先更新数据库，再删除缓存</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BC%98%E5%85%88%E4%BD%BF%E7%94%A8%E2%80%9C%E5%85%88%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E5%86%8D%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98%E2%80%9D%EF%BC%8C%E5%8E%9F%E5%9B%A0%EF%BC%9A"><span class="nav-number">2.2.1.2.3.</span> <span class="nav-text">优先使用“先更新数据库再删除缓存”，原因：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E9%92%88%E5%AF%B9%E8%AF%BB%E5%86%99%E7%BC%93%E5%AD%98%EF%BC%88%E5%85%88%E6%9B%B4%E6%96%B0%E7%BC%93%E5%AD%98%E5%86%8D%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%89"><span class="nav-number">2.2.2.</span> <span class="nav-text">2.2 针对读写缓存（先更新缓存再更新数据库）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#A-%E6%97%A0%E5%B9%B6%E5%8F%91%E6%83%85%E5%86%B5-%E4%B8%8E%E5%8F%AA%E8%AF%BB%E7%BC%93%E5%AD%98%E5%A4%84%E7%90%86%E6%8E%AA%E6%96%BD%E4%B8%80%E6%A0%B7"><span class="nav-number">2.2.2.1.</span> <span class="nav-text">A. 无并发情况(与只读缓存处理措施一样)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B-%E9%AB%98%E5%B9%B6%E5%8F%91%E6%83%85%E5%86%B5-1"><span class="nav-number">2.2.2.2.</span> <span class="nav-text">B. 高并发情况</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E5%BC%BA%E4%B8%80%E8%87%B4%E6%80%A7%E7%AD%96%E7%95%A5"><span class="nav-number">2.2.3.</span> <span class="nav-text">2.3 强一致性策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-%E5%B0%8F%E7%BB%93"><span class="nav-number">2.2.4.</span> <span class="nav-text">2.4 小结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E4%B8%AD%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">2.2.5.</span> <span class="nav-text">3. 数据一致性中需要注意的其他问题有哪些？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-k-v%E5%A4%A7%E5%B0%8F%E7%9A%84%E5%90%88%E7%90%86%E8%AE%BE%E7%BD%AE"><span class="nav-number">2.2.5.1.</span> <span class="nav-text">3.1 k-v大小的合理设置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-%E9%81%BF%E5%85%8D%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98%E5%AF%BC%E8%87%B4%E7%BC%93%E5%AD%98%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B4%A9%E6%BA%83%EF%BC%8C%E8%BF%9B%E8%80%8C%E7%AE%80%E7%9B%B4%E5%AF%BC%E8%87%B4%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E7%AD%96%E7%95%A5%E5%A4%B1%E6%95%88"><span class="nav-number">2.2.5.2.</span> <span class="nav-text">3.2 避免其他问题导致缓存服务器崩溃，进而简直导致数据一致性策略失效</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-%E6%96%B9%E6%A1%88%E9%80%89%E5%AE%9A%E7%9A%84%E6%80%9D%E8%B7%AF"><span class="nav-number">2.2.5.3.</span> <span class="nav-text">3.3 方案选定的思路</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Tianxing"
      src="/images/webb.jpg">
  <p class="site-author-name" itemprop="name">Tianxing</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">5</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/litianxing201930640094" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;litianxing201930640094" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/cca9620crd@163.com" title="E-Mail → cca9620crd@163.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Tianxing</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="//cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/three.min.js"></script>
    <script defer src="//cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/canvas_lines.min.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://user1.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  var disqus_config = function() {
    this.page.url = "https://litianxing201930640094.github.io/2022/08/13/mysql%E5%92%8Credis/";
    this.page.identifier = "2022/08/13/mysql和redis/";
    this.page.title = "mysql和redis";
    };
  NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://user1.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>

</body>
</html>
